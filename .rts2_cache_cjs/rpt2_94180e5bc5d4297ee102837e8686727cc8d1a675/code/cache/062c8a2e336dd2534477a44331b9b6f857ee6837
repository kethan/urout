{"code":"import reg from './regexparam';\r\nimport parser from './url';\r\nexport class Router {\r\n    constructor(opts = {}) {\r\n        this.routes = [];\r\n        this.parse = parser;\r\n        this.handler = this.handler.bind(this);\r\n        this.onError = opts.onError || this.onErrorI;\r\n        this.onNoMatch = opts.onNoMatch || this.onError.bind(null, { code: 404 });\r\n        this.attach = (req, res) => setTimeout(this.handler, 0, req, res);\r\n        this.all = this.add.bind(this, '');\r\n        this.get = this.add.bind(this, 'GET');\r\n        this.head = this.add.bind(this, 'HEAD');\r\n        this.patch = this.add.bind(this, 'PATCH');\r\n        this.options = this.add.bind(this, 'OPTIONS');\r\n        this.connect = this.add.bind(this, 'CONNECT');\r\n        this.delete = this.add.bind(this, 'DELETE');\r\n        this.trace = this.add.bind(this, 'TRACE');\r\n        this.post = this.add.bind(this, 'POST');\r\n        this.put = this.add.bind(this, 'PUT');\r\n    }\r\n    useI(route, ...fns) {\r\n        let handlers = [].concat.apply([], fns);\r\n        let { keys, pattern } = reg(route, true);\r\n        this.routes.push({ keys, pattern, method: '', handlers });\r\n        return this;\r\n    }\r\n    use(route, ...fns) {\r\n        if (typeof route === 'function') {\r\n            this.useI('/', route, ...fns);\r\n        }\r\n        else if (route === '/') {\r\n            this.useI(route, ...fns);\r\n        }\r\n        else {\r\n            this.useI(route, (req, _, next) => {\r\n                if (typeof route === 'string') {\r\n                    let len = route.length;\r\n                    route.indexOf('/') === 0 || len++;\r\n                    req.url = req.url.substring(len) || '/';\r\n                    req.path = req.path.substring(len) || '/';\r\n                }\r\n                else {\r\n                    req.url = req.url.replace(route, '') || '/';\r\n                    req.path = req.path.replace(route, '') || '/';\r\n                }\r\n                next();\r\n            }, ...fns.map((fn) => fn instanceof Router ? fn.attach : fn), (req, _, next) => {\r\n                req.url = req._parsedUrl.href;\r\n                req.path = req._parsedUrl.pathname;\r\n                next();\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n    onErrorI(err, req, res) {\r\n        let code = (res.statusCode = err.code || err.status || 500);\r\n        res.end(err.length && err || err.message);\r\n    }\r\n    add(method, route, ...fns) {\r\n        let { keys, pattern } = reg(route);\r\n        let handlers = [].concat.apply([], fns);\r\n        this.routes.push({ keys, pattern, method, handlers });\r\n        return this;\r\n    }\r\n    handler(req, res, next) {\r\n        let info = this.parse(req, true);\r\n        let obj = this.find(req.method, req.path = info.pathname);\r\n        req.params = obj.params;\r\n        req.originalUrl = req.originalUrl || req.url;\r\n        req.query = info.query || {};\r\n        req.search = info.search;\r\n        try {\r\n            let i = 0, arr = obj.handlers.concat(this.onNoMatch), len = arr.length;\r\n            let loop = () => res.finished || (i < len) && arr[i++](req, res, next);\r\n            next = next || ((err) => err ? this.onError(err, req, res, next) : loop());\r\n            loop(); // init\r\n        }\r\n        catch (err) {\r\n            this.onError(err, req, res, next);\r\n        }\r\n    }\r\n    find(method, url) {\r\n        let isHEAD = (method === 'HEAD');\r\n        let i = 0, j = 0, k, tmp, arr = this.routes;\r\n        let matches = [], params = {}, handlers = [];\r\n        for (; i < arr.length; i++) {\r\n            tmp = arr[i];\r\n            if (tmp.method.length === 0 || tmp.method === method || isHEAD && tmp.method === 'GET') {\r\n                if (tmp.keys.length == 0) {\r\n                    matches = tmp.pattern.exec(url);\r\n                    if (matches === null)\r\n                        continue;\r\n                    if (matches.groups !== void 0)\r\n                        for (k in matches.groups)\r\n                            params[k] = matches.groups[k];\r\n                    tmp.handlers.length > 1 ? (handlers = handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);\r\n                }\r\n                else if (tmp.keys.length > 0) {\r\n                    matches = tmp.pattern.exec(url);\r\n                    if (matches === null)\r\n                        continue;\r\n                    for (j = 0; j < tmp.keys.length;)\r\n                        params[tmp.keys[j]] = matches[++j];\r\n                    tmp.handlers.length > 1 ? (handlers = handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);\r\n                }\r\n                else if (tmp.pattern.test(url)) {\r\n                    tmp.handlers.length > 1 ? (handlers = handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);\r\n                }\r\n            }\r\n        }\r\n        return { params, handlers };\r\n    }\r\n}\r\n","dts":{"name":"/home/kethan/Desktop/final/router/router/urout.d.ts","writeByteOrderMark":false,"text":"export interface Route {\r\n    keys: string[];\r\n    pattern: RegExp;\r\n    method: string;\r\n    handlers: Function[];\r\n}\r\nexport interface Opts {\r\n    onError?(err: any, req: any, res: any): void;\r\n    onNoMatch?(req: any, res: any, next: Function): void;\r\n    server?: any;\r\n}\r\nexport interface FindResult<T> {\r\n    params: {\r\n        [k: string]: string;\r\n    };\r\n    handlers: T[];\r\n}\r\nexport declare type NextHandler = (req: any, res: any, next: Function) => void;\r\nexport declare type EndHandler = (req: any, res: any) => void;\r\nexport declare type Handler = NextHandler | EndHandler | Router;\r\nexport declare type Method = (pattern: string | RegExp, ...handlers: Handler[]) => Router;\r\nexport declare type Middleware = (req: any, res: any, next: Function) => void;\r\nexport declare class Router<T = any> {\r\n    all: Method | any;\r\n    get: Method | any;\r\n    head: Method | any;\r\n    patch: Method | any;\r\n    options: Method | any;\r\n    connect: Method | any;\r\n    delete: Method | any;\r\n    trace: Method | any;\r\n    post: Method | any;\r\n    put: Method | any;\r\n    private routes;\r\n    private parse;\r\n    private onError;\r\n    private onNoMatch;\r\n    private attach;\r\n    constructor(opts?: Opts);\r\n    private useI;\r\n    use(...fns: any): this;\r\n    private onErrorI;\r\n    add(method: string, route?: string, ...fns: Function[] | any): this;\r\n    handler(req: any, res: any, next?: any): void;\r\n    private find;\r\n}\r\n"}}
